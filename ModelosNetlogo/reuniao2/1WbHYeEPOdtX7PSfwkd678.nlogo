;; This file was generated by the Behaviour Composer at modelling4all.org on Mon Mar 18 20:13:39 UTC 2019
;; The model can be found at http://m.modelling4all.org/m/?frozen=1WbHYeEPOdtX7PSfwkd678

breed [objects object]

turtles-own [
 scheduled-behaviours behaviours-at-tick-start current-behaviours current-behaviour behaviour-removals rules 
 kind dead dirty
 my-energy 
 ]

breed [pens pen]

; The following are needed by the Behaviour Composer
globals [
 time cycle-finish-time behind-schedule times-scheduled frame-duration delta-t stop-running
 world-geometry mean-x mean-y mean-z plotting-commands histogram-plotting-commands 
 behaviour-procedure-numbers behaviour-names internal-the-other 
 button-command radian need-to-clear-drawing
 observer-commands 
 objects-with-something-to-do
 maximum-plot-generations plot-generation
 prototypes total-time
 update-patch-attributes-needed
 state-restored-after-setup
 temp
]

patches-own [
  grama-of-patch 
  log-patch-attributes]

to the-model [ globals-not-to-be-initialised ] 
   initialise-globals globals-not-to-be-initialised 
   create-objects 3 
                  [ set kind 
                        "Agente" 
                    initialise-object ] 
   create-objects 1 
                  [ set kind 
                        "Ambiente" 
                    initialise-object 
                    set hidden? true ] 
   ask all-of-kind "Agente" 
       [ -INITIAL-ENERGY-920 
         -COR-INICIAL-DOS-AGENTES-5 
         -JUMP-TO-UNOCCUPIED-LOCATION-IN-REGION-1980 
         -INTERACT-WITH-ANOTHER-655 
         -ENVELHECIMENTO-6 
         -DIE-5091 ] 
   ask all-of-kind "Ambiente" 
       [ -DEFINE-ATRIBUTO-GRAMA-PATCHES-3 
         -DEFINE-COR-PATCHES-9 ] 
end

to -INITIAL-ENERGY-920
                       ; Set an attribute, parameter, or Netlogo variable to a new value.  
   set my-energy 
       10 
end

to -COR-INICIAL-DOS-AGENTES-5
                              ; Change the color of this agent.  
   let cor_ 
       ( my-energy * 10 ) 
   set color 
       ( list cor_ 0 0 ) 
end

to -JUMP-TO-UNOCCUPIED-LOCATION-IN-REGION-1980
                                               ; Jump to a random unoccupied location in the specified region.  
   let unoccupied-location 
       random-unoccupied-location ( min-pxcor ) ( max-pxcor ) ( min-pycor ) ( max-pycor ) 
   set xcor 
       first unoccupied-location 
   set ycor 
       second unoccupied-location 
end

to -CONSOME-O-ALIMENTO-1
                         ; Set an attribute, parameter, or Netlogo variable to a new value.  
   set grama-of-patch 
       grama-of-patch - 1 
end

to -REPLICAÇÃO-6
                 ; Create exact copies of this agent. The newly created copies can be given any additional behaviours.  
   if random-float 1.0 <= ( 0.3 ) 
      [ add-copies 1 [ ] ] 
end

to -INTERACT-WITH-ANOTHER-655
                              ; Interact with anyone who meets the specified conditions.  
   do-after ( 1 ) 
            [ [] ->  do-every ( 1 ) 
                            [ [] ->  let target-agents 
                                       other all-individuals with [ grama-of-patch > 0 ] 
                                   if any? target-agents 
                                      [ ask one-of target-agents 
                                            [ -CONSOME-O-ALIMENTO-1 ] 
                                        -REPLICAÇÃO-6 ] ] ] 
end

to -ENVELHECIMENTO-6
                     ; Set an attribute, parameter, or Netlogo variable to a new value.  
   do-every ( 1 ) 
            [ [] ->  set my-energy 
                       my-energy - 1 ] 
end

to -DIE-5091
             ; Remove this agent from the model.  
   whenever [ [] ->  my-energy <= 0 ] 
            [ [] ->  set dead 
                       true ] 
end

to -DEFINE-ATRIBUTO-GRAMA-PATCHES-3
                                    ; Set the color of each patch to a random color.  
   ask-every-patch [ [] ->  set grama-of-patch 
                              10 ] 
end

to -DEFINE-COR-PATCHES-9
                         ; Set the color of each patch to a random color.  
   do-every ( 1 ) 
            [ [] ->  ask-every-patch [ [] ->  set pcolor 
                                              ( list 0 ( grama-of-patch * 10 ) 0 ) ] ] 
end

to-report random-unoccupied-location [min-xcor max-xcor min-ycor max-ycor]
  let unoccupied-patch one-of patches with 
                                      [min-xcor <= pxcor and
                                       max-xcor >= pxcor and
                                       min-ycor <= pycor and
                                       max-ycor >= pycor and
                                       not any? objects-here with [not hidden?]]
 if-else is-patch? unoccupied-patch
   [report [(list pxcor pycor)] of unoccupied-patch]
   [report (list xcor ycor)]
end

to-report update-attributes
  report false
end

to initialise-patch-attributes
 set log-patch-attributes []
end

to initialise-globals [globals-not-to-be-initialised]
 set update-patch-attributes-needed false
end

to update-patch-attributes
end

to-report update-turtle-state
 report false
end

to initialise-previous-state
end

to update-all-turtle-states
end

to initialise-attributes
end

; The following are NetLogo library procedures and reporters used by the BehaviourComposer
; New BSD license
; See http://modelling4all.org
; Authored by Ken Kahn; Last updated 16 January 2017 to be compatible with NetLogo 6.0



to start [globals-not-to-be-initialised]
 initialise globals-not-to-be-initialised
 the-model globals-not-to-be-initialised
 finish-setup
 create-pens 1 ; for drawing lines
 ask pens [hide-turtle]
end

to setup
  setup-except []
end

to setup-except [globals-not-to-be-initialised]
 start globals-not-to-be-initialised
 set total-time 0
 if go-until (delta-t - .000001) []  ; ignore result
 ask objects [initialise-previous-state]
end

to initialise [globals-not-to-be-initialised]
 let saved-global-values map runresult globals-not-to-be-initialised
 if-else maximum-plot-generations > 0
    [if-else plot-generation <= maximum-plot-generations
        [let next-plot-generation plot-generation + 1
         ; clear all but plots and output
         clear-patches
         clear-drawing
         clear-turtles
         clear-globals
         set plot-generation next-plot-generation]
        [clear-all
         set plot-generation 0]]
    [clear-all]
 ;; restore the value of any variables in globals-not-to-be-initialised
 let i 0
 while [i < length globals-not-to-be-initialised]
       [let variable item i globals-not-to-be-initialised
        let value item i saved-global-values
        if (not is-number? value and not is-boolean? value and not is-list? value) [set value (word "\"" value "\"")]
        run (word "set " variable " " value)
        set i i + 1]
 reset-timer
 set time -1
 set times-scheduled []
 set behind-schedule 0
 set plotting-commands []
 set histogram-plotting-commands []
 set button-command ""
 set radian 57.29577951308232
 set need-to-clear-drawing false
 set observer-commands []
 set stop-running false
 if delta-t = 0 [set delta-t 1] ; give default value if none given
 if frame-duration = 0 [set frame-duration delta-t]
 if world-geometry = 0 [set world-geometry 1]
 ask-every-patch [ [] -> initialise-patch-attributes ]
 reset-ticks
end

to initialise-object
 set scheduled-behaviours []
 set current-behaviours []
 set behaviour-removals []
 set rules []
 set dead false
 initialise-attributes
end

to finish-setup
 ; faster than ask objects since doesn't shuffle
 set objects-with-something-to-do objects
 let ignore1 objects with [update-attributes]
 ask objects with [rules != []] [run-rules]
 update-all-turtle-states
 set time 0
end

to go
 reset-timer ; reset timer so pause and resume don't have leftover time
 if go-until -1
    [set stop-running false ; so it can be started up again
     stop]
    set total-time total-time + timer
end

to setup-only-if-needed
  if times-scheduled = 0 [setup]
end

to-report go-until [stop-time]
 ; this is run by the 'go' button and runs the scheduled events and updates the turtle states and plots
 setup-only-if-needed
 if observer-commands != []
    [run-observer-commands]
 if-else times-scheduled = []
   ; following uses a hack to avoid the overhead of ask shuffling the agent set
   [set objects-with-something-to-do objects with [rules != []]
    ask objects-with-something-to-do [run-rules] ; nothing scheduled but rules may be triggered by time
    ; rules may have added behaviours or set 'dead' so can't re-use objects-with-something-to-do
    ask objects [finish-tick]
    if observer-commands != []
       [run-observer-commands]
    set time time + frame-duration]
   [if-else time <= 0
      [set cycle-finish-time first times-scheduled]
      [set cycle-finish-time cycle-finish-time + frame-duration]
     if stop-time > 0 [set cycle-finish-time stop-time]
     while [times-scheduled != [] and first times-scheduled <= cycle-finish-time]
       [; nothing happening so skip ahead to next event
        set time first times-scheduled
        set times-scheduled but-first times-scheduled
        set objects-with-something-to-do objects with [scheduled-behaviours != [] or rules != []]
        ask objects-with-something-to-do [start-tick]
        ; above may have added behaviours or set 'dead' so can't re-use objects-with-something-to-do
        ask objects [finish-tick]
        if observer-commands != []
           [run-observer-commands]
        if need-to-clear-drawing
           [clear-drawing
            set need-to-clear-drawing false]]]
 if observer-commands != []
    [run-observer-commands]
 update-all-turtle-states
 if update-patch-attributes-needed [ask-every-patch [ [] -> update-patch-attributes ]]
 tick-advance time - ticks
 run-plotting-commands
 report not any? objects = 0 or stop-running or (stop-time > 0 and time >= stop-time)
end

to run-observer-commands
  let commands observer-commands
  set observer-commands []
  ; run each command without ANY commands pending
  forEach commands [ [?1] -> run ?1 ]
end

to run-plotting-commands
 forEach plotting-commands [ [?1] -> if is-agent? first ?1 [ask first ?1 [update-plot item 1 ?1 runresult item 2 ?1 runresult item 3 ?1]] ]
 forEach histogram-plotting-commands [ [?1] -> if is-agent? first ?1 [ask first ?1 [update-histogram item 1 ?1 item 2 ?1 item 3 ?1]] ]
end

to update-plot [name-of-plot x y]
 if time >= 0
  [set-current-plot name-of-plot
   plotxy x y]
end

to update-histogram [name-of-plot population-reporter value-reporter]
 if time >= 0
  [set-current-plot name-of-plot
   histogram [runresult value-reporter] of runresult population-reporter]
end

;; behaviours are represented by a list:
;; scheduled-time behaviour-name
;; behaviours are kept in ascending order of the scheduled-time

to remove-behaviour-now [name]
 set scheduled-behaviours remove-behaviour-from-list name scheduled-behaviours
end

to do-every [interval actions]
 ; does it now and schedules the next occurrence interval ticks in the future
 ; schedules first in case action updates the current-behaviour variable
 if-else not is-number? interval or interval <= 0
   [user-message (word "Can only repeat something a positive number of times. Not " interval " " actions)]
   [if-else time < 0
      [insert-behaviour 0 (list (list actions interval))]
      [do-every-internal interval actions]]
end

to do-every-internal [interval actions]
 insert-behaviour time + interval (list (list actions interval))
 run-procedure actions
end

to do-every-dynamic [interval-reporter actions]
 insert-behaviour time + run-result interval-reporter (list (list actions interval-reporter))
 run-procedure actions
end

to do-after [duration actions]
 ; schedules this duration ticks in the future
 if-else is-list? current-behaviour
    ; from the time this event was scheduled to run; not necessarily the current time
    [do-at-time first current-behaviour + duration actions]
    [if-else time > 0
       [do-at-time time + duration actions]
       [do-at-time duration actions]]
end

to do-at-time [scheduled-time actions]
 if-else scheduled-time <= time
   [run actions]
   [insert-behaviour scheduled-time (list actions)]
end

to add-copies [n behaviours]
 hatch n
       [set dead false
        let ignore update-attributes
        if-else (behaviours-at-tick-start = 0)
           ; this is called during initialisation so fall back on the old way of doing things
           [set scheduled-behaviours merge-behaviours scheduled-behaviours current-behaviours
            set scheduled-behaviours remove current-behaviour scheduled-behaviours]
           [set scheduled-behaviours behaviours-at-tick-start]
        forEach behaviours [ [?1] -> run ?1 ] ]
end

to start-tick
 set behaviours-at-tick-start scheduled-behaviours
 set current-behaviours scheduled-behaviours
 set scheduled-behaviours []
 while [current-behaviours != []]
       [let simulation-time first first current-behaviours
        if-else simulation-time > time
          [set scheduled-behaviours merge-behaviours scheduled-behaviours current-behaviours
           set current-behaviours []] ; stop this round
          [set current-behaviour first current-behaviours
           forEach but-first current-behaviour run-procedure
           set current-behaviour 0
           ; procedure may have reset current-behaviours to []
           if current-behaviours != []
              [set current-behaviours but-first current-behaviours]]]
 if rules != [] [run-rules]
 if behaviour-removals != []
    [forEach behaviour-removals
        [ [?1] -> ask first ?1 [remove-behaviour-now item 1 ?1] ]
     set behaviour-removals []]
end

to finish-tick
 ; this should happen after all objects have run start-tick
 let ignore update-attributes
 if dead [die]
end

to-report all-of-kind [kind-name]
 report objects with [kind = kind-name]
end

to whenever [condition action]
 set rules fput (list condition action true) rules
end

to run-rules
 let current-rules rules
 set rules []
 ; so can remove a rule below while still going down the list
 ;; could add error handling below
 forEach current-rules
    [ [?1] -> if-else runresult first ?1
       [run first but-first ?1
        if item 2 ?1
           ; is a 'whenever' rule so put it back on the list of rules
           [set rules fput ?1 rules]]
       [set rules fput ?1 rules] ]
end

to insert-behaviour [scheduled-time rest-of-behaviour]
 ; inserts in schedule keeping it sorted by scheduled time
 set times-scheduled insert-ordered scheduled-time times-scheduled
 set scheduled-behaviours insert-behaviour-in-list scheduled-time rest-of-behaviour scheduled-behaviours
end

to-report insert-ordered [new-time times]
  if-else member? new-time times
    [report times]
    [report sort fput new-time times]
end

to-report insert-behaviour-in-list [scheduled-time rest-of-behaviour behaviours]
 ; recursive version took 10% longer
 let earlier-behaviours []
 while [behaviours != []]
    [let current-time first first behaviours
      if current-time = scheduled-time
        [let new-behaviour lput first rest-of-behaviour first behaviours
          report sentence earlier-behaviours fput new-behaviour but-first behaviours]
      if current-time > scheduled-time
        [report sentence earlier-behaviours fput fput scheduled-time rest-of-behaviour behaviours]
     set earlier-behaviours lput first behaviours earlier-behaviours
     set behaviours but-first behaviours]
 report sentence earlier-behaviours (list fput scheduled-time rest-of-behaviour)
end

to-report remove-behaviour-from-list [procedure-name behaviours]
 report map [ [?1] -> remove-behaviour-from-behaviours-at-time-t procedure-name ?1 ] behaviours
end

to-report remove-behaviour-from-behaviours-at-time-t [procedure-name behaviours-at-time-t]
 forEach but-first behaviours-at-time-t ; first is the time -- skip that
   [ [?1] -> if equivalent-micro-behaviour? (ifelse-value is-list? ?1 [first ?1] [?1]) procedure-name
      [report remove ?1 behaviours-at-time-t] ]
 report behaviours-at-time-t
end

to-report equivalent-micro-behaviour? [name-1 name-2]
 if (not is-string? name-1)
    [set name-1 (anonymous-function-to-name name-1)]
 if (not is-string? name-2)
    [set name-2 (anonymous-function-to-name name-2)]
 if (name-1 = name-2) [report true]
 ; ignore serial number since can be multiple occurrences of the same micro-behaviour
 if (substring name-1 0 (length name-1 - 8) = substring name-2 0 (length name-2 - 8)) [report true]
 report false
end

to-report anonymous-function-to-name [f]
  ; extracts the name where the anonymous function was defined
  let s (word f)
  let start-index position " procedure " s
  if (start-index = false) [report s]
  set start-index start-index + length " procedure "
  set s substring s start-index (length s - 1)
  let stop-index position ": " s
  if (stop-index = false) [report s]
  report substring s 0 stop-index
end

to remove-behaviours [behaviours]
 forEach behaviours [ [?1] -> remove-behaviour ?1 ]
end

to remove-behaviour [name]
  set behaviour-removals fput (list self name) behaviour-removals
end

to-report merge-behaviours [behaviours1 behaviours2]
 ; both lists are already sorted
 if behaviours1 = [] [report behaviours2]
 if behaviours2 = [] [report behaviours1]
 if-else first first behaviours1 < first first behaviours2
   [report fput first behaviours1 merge-behaviours but-first behaviours1 behaviours2]
   [report fput first behaviours2 merge-behaviours behaviours1 but-first behaviours2]
end

to-report second [l]
 report first but-first l
end

to-report all-individuals
 report objects with [not hidden?]
end

to ask-every-patch [procedure-name]
 ; a hack but faster since doesn't randomise the patches as ask does
 let ignore patches with [run-false procedure-name]
end

to-report run-false [procedure-name]
 run procedure-name
 report false
end

to-report list-to-agentset [agent-list]
 ; deprecated but kept for backwards compatibility
 report turtle-set agent-list
end

to run-procedure [name]
 if-else is-list? name
    [let target-or-frequency item 1 name
     if-else is-number? target-or-frequency
        [do-every-internal target-or-frequency first name]
        [if-else is-agent? target-or-frequency
            [ask target-or-frequency [run first name]]
            [do-every-dynamic target-or-frequency first name] ]]
    [run name]
end

@#$#@#$#@
GRAPHICS-WINDOW
104
10
618
545
10
10
24.0
1
10
1
1
1
0
1
1
1
-10
10
-10
10
1
0
1
time
30.0

BUTTON
5
5
66
40
SETUP
setup
NIL
1
T
OBSERVER
NIL
S
NIL
NIL
1

BUTTON
5
45
66
80
GO
go
T
1
T
OBSERVER
NIL
G
NIL
NIL
1

BUTTON
5
85
68
118
PAUSE
set stop-running true
NIL
1
T
OBSERVER
NIL
.
NIL
NIL
1

@#$#@#$#@
## WHAT IS IT?

(a general understanding of what the model is trying to show or explain)

## HOW IT WORKS

(what rules the agents use to create the overall behavior of the model)

## HOW TO USE IT

(how to use the model, including a description of each of the items in the Interface tab)

## THINGS TO NOTICE

(suggested things for the user to notice while running the model)

## THINGS TO TRY

(suggested things for the user to try to do (move sliders, switches, etc.) with the model)

## EXTENDING THE MODEL

(suggested things to add or change in the Code tab to make the model more complicated, detailed, accurate, etc.)

## NETLOGO FEATURES

(interesting or unusual features of NetLogo that the model uses, particularly in the Code tab; or where workarounds were needed for missing features)

## RELATED MODELS

(models in the NetLogo Models Library and elsewhere which are of related interest)

## CREDITS AND REFERENCES

(a reference to the model's URL on the web if it has one, as well as any other necessary credits, citations, and links)

@#$#@#$#@
default
true
0
Polygon -7500403 true true 150 5 40 250 150 205 260 250

@#$#@#$#@
NetLogo 6.0.1
@#$#@#$#@
default
0.0
-0.2 0 0.0 1.0
0.0 1 1.0 0.0
0.2 0 0.0 1.0
link direction
true
0
Line -7500403 true 150 150 90 180
Line -7500403 true 150 150 210 180
@#$#@#$#@
@#$#@#$#@
@#$#@#$#@
@#$#@#$#@
default
0.0
-0.2 0 0.0 1.0
0.0 1 1.0 0.0
0.2 0 0.0 1.0
link direction
true
0
Line -7500403 true 150 150 90 180
Line -7500403 true 150 150 210 180

@#$#@#$#@
0
@#$#@#$#@
