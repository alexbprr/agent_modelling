;; This file was generated by the Behaviour Composer at modelling4all.org on Tue Nov 13 18:05:54 UTC 2018
;; The model can be found at http://m.modelling4all.org/m/?frozen=H7rnZutysP7tZVCutn7S6c

breed [objects object]

turtles-own [
 scheduled-behaviours behaviours-at-tick-start current-behaviours current-behaviour behaviour-removals rules 
 kind dead previous-xcor previous-ycor previous-heading dirty
 my-x 
 my-next-x my-next-x-set 
 my-y 
 my-next-y my-next-y-set 
 my-heading 
 my-next-heading my-next-heading-set 
 my-energy 
 ]

breed [pens pen]

; The following are needed by the Behaviour Composer
globals [
 time cycle-finish-time behind-schedule times-scheduled frame-duration delta-t stop-running
 world-geometry mean-x mean-y mean-z plotting-commands histogram-plotting-commands 
 behaviour-procedure-numbers behaviour-names internal-the-other 
 button-command radian need-to-clear-drawing
 observer-commands 
 objects-with-something-to-do
 maximum-plot-generations plot-generation
 prototypes total-time
 update-patch-attributes-needed
 state-restored-after-setup
 temp
]

to the-model [ globals-not-to-be-initialised ] 
   initialise-globals globals-not-to-be-initialised 
   create-objects 3 
                  [ set kind 
                        "Wolf" 
                    initialise-object ] 
   create-objects 10 
                  [ set kind 
                        "Sheep" 
                    initialise-object ] 
   create-objects 1 
                  [ set kind 
                        "World" 
                    initialise-object 
                    set hidden? true ] 
   create-objects 1 
                  [ set kind 
                        "Observer" 
                    initialise-object 
                    set hidden? true ] 
   ask all-of-kind "Wolf" 
       [ -SHAPE-3838 
         -COLOR-5435 
         -JUMP-TO-UNOCCUPIED-LOCATION-IN-REGION-1718 
         -FORWARD-REPEATEDLY-1940 
         -TURN-REPEATEDLY-RANDOMLY-1197 
         -RANDOM-HEADING-1006 
         -EAT-SHEEP-1623 
         -INITIAL-ENERGY-879 
         -CONSUME-ENERGY-901 
         -DIE-WHEN-NO-ENERGY-871 
         -WOLF-REPRODUCTION-901 ] 
   ask all-of-kind "Sheep" 
       [ -SHAPE-3840 
         -COLOR-5437 
         -JUMP-TO-UNOCCUPIED-LOCATION-IN-REGION-1719 
         -FORWARD-REPEATEDLY-1938 
         -TURN-REPEATEDLY-RANDOMLY-1196 
         -EC_PDE2HQJ6HL4DAB-HY47 ] 
   ask all-of-kind "World" 
       [ -COLOR-OF-ALL-PATCHES-523 ] 
   ask all-of-kind "Observer" 
       [ -PLOT-WOLFS-4 
         -PLOT-SHEEPS-140 ] 
end

to -SHAPE-3838
               ; Change the appearance to one of the defined shapes.  
   set shape 
       "wolf 2" 
end

to -COLOR-5435
               ; Change the color of this agent.  
   set color 
       cyan 
end

to -JUMP-TO-UNOCCUPIED-LOCATION-IN-REGION-1718
                                               ; Jump to a random unoccupied location in the specified region.  
   let unoccupied-location 
       random-unoccupied-location ( min-pxcor ) ( max-pxcor ) ( min-pycor ) ( max-pycor ) 
   set my-x 
       first unoccupied-location 
   set my-y 
       second unoccupied-location 
end

to -FORWARD-REPEATEDLY-1940
                            ; Repeatedly go forward in the direction of my heading.  
   do-every ( 1 ) 
            [ [] ->  go-forward 0.2 ] 
end

to -TURN-REPEATEDLY-RANDOMLY-1197
                                  ; Repeatedly turn a random number of degrees to change my heading.  
   do-every ( 1 ) 
            [ [] ->  turn-right random-number-between -30 30 ] 
end

to -RANDOM-HEADING-1006
                        ; Set my-heading to a random angle.  
   set my-heading 
       random-number-between 0 360 
end

to -DIE-4959
             ; Remove this agent from the model.  
   set dead 
       true 
end

to -ENERGY-GAIN-FROM-EATING-3
                              ; Set an attribute, parameter, or Netlogo variable to a new value.  
   set my-energy 
       my-energy + 40 
end

to -EAT-SHEEP-1623
                   ; Interact with anyone who meets the specified conditions.  
   do-every ( 1 ) 
            [ [] ->  let target-agents 
                       objects-here with [ kind = "Sheep" and not dead ] 
                   if any? target-agents 
                      [ ask one-of target-agents 
                            [ -DIE-4959 ] 
                        -ENERGY-GAIN-FROM-EATING-3 ] ] 
end

to -INITIAL-ENERGY-879
                       ; Sei initial energy level to a random value between 1 and 40  
   set my-energy 
       random-integer-between 80 100 
end

to -CONSUME-ENERGY-901
                       ; Set an attribute, parameter, or Netlogo variable to a new value.  
   do-every ( 10 ) 
            [ [] ->  set my-energy 
                       my-energy - 1 ] 
end

to -DIE-WHEN-NO-ENERGY-871
                           ; Remove this agent from the model.  
   whenever [ [] ->  my-energy <= 0 and time > 0 ] 
            [ [] ->  set dead 
                       true ] 
end

to -SPLIT-ENERGY-1480
                      ; Set an attribute, parameter, or Netlogo variable to a new value.  
   set my-energy 
       my-energy / 2 
end

to -ADD-CHILD-130
                  ; Create exact copies of this agent. The newly created copies can be given any additional behaviours.  
   add-copies 1 [ ] 
end

to -WOLF-REPRODUCTION-901
                          ; Add a list of behaviours
                          ; (a way to package up several behaviours into a single unit).  
   do-every ( 1 ) 
            [ [] ->  if random-float 1.0 <= ( 0.02 ) 
                      [ -SPLIT-ENERGY-1480 
                        -ADD-CHILD-130 ] ] 
end

to -SHAPE-3840
               ; Change the appearance to one of the defined shapes.  
   set shape 
       "sheep 2" 
end

to -COLOR-5437
               ; Change the color of this agent.  
   set color 
       gray 
end

to -JUMP-TO-UNOCCUPIED-LOCATION-IN-REGION-1719
                                               ; Jump to a random unoccupied location in the specified region.  
   let unoccupied-location 
       random-unoccupied-location ( min-pxcor ) ( max-pxcor ) ( min-pycor ) ( max-pycor ) 
   set my-x 
       first unoccupied-location 
   set my-y 
       second unoccupied-location 
end

to -FORWARD-REPEATEDLY-1938
                            ; Repeatedly go forward in the direction of my heading.  
   do-every ( 1 ) 
            [ [] ->  go-forward 0.1 ] 
end

to -TURN-REPEATEDLY-RANDOMLY-1196
                                  ; Repeatedly turn a random number of degrees to change my heading.  
   do-every ( 1 ) 
            [ [] ->  turn-right random-number-between -30 30 ] 
end

to -EC_PDE2HQJ6HL4DAB-HY47
                           ; Set my-heading to a random angle.  
   set my-heading 
       random-number-between 0 360 
end

to -COLOR-OF-ALL-PATCHES-523
                             ; Set the color of all the patches of the world.  
   ask-every-patch [ [] ->  set pcolor 
                              white ] 
end

to -PLOT-WOLFS-4
                 ; Graph data on top of a plot with a fresh pen.  
   do-every ( 1 ) 
            [ [] ->  set-current-plot "Wolves x Sheeps" 
                   create-temporary-plot-pen "Wolves"
                                             ; this name will be used in the legend if enabled 
                   set-plot-pen-color blue 
                   set-plot-pen-mode 0
                                     ; 0 for line, 1 for bar, 2 for point
                                     ; plot-pen-reset ; remove the ';' in the box to erase everything drawn by this pen 
                   add-to-plot time count all-of-kind "Wolf" ] 
end

to -PLOT-SHEEPS-140
                    ; Graph data on top of a plot with a fresh pen.  
   do-every ( 1 ) 
            [ [] ->  set-current-plot "Wolves x Sheeps" 
                   create-temporary-plot-pen "Sheeps"
                                             ; this name will be used in the legend if enabled 
                   set-plot-pen-color red 
                   set-plot-pen-mode 0
                                     ; 0 for line, 1 for bar, 2 for point
                                     ; plot-pen-reset ; remove the ';' in the box to erase everything drawn by this pen 
                   add-to-plot time count all-of-kind "Sheep" ] 
end

to-report random-integer-between [n1 n2]
 report n1 + random (1 + n2 - n1)
end

to-report random-number-between [n1 n2]
 report n1 + random-float (n2 - n1)
end

to-report random-unoccupied-location [min-xcor max-xcor min-ycor max-ycor]
  let unoccupied-patch one-of patches with 
                                      [min-xcor <= pxcor and
                                       max-xcor >= pxcor and
                                       min-ycor <= pycor and
                                       max-ycor >= pycor and
                                       not any? objects-here with [not hidden?]]
 if-else is-patch? unoccupied-patch
   [report [(list pxcor pycor)] of unoccupied-patch]
   [report (list xcor ycor)]
end

to-report update-attributes
  ifElse my-next-x-set
    [set my-x my-next-x
     set my-next-x-set false]
    [set my-next-x my-x]
  ifElse my-next-y-set
    [set my-y my-next-y
     set my-next-y-set false]
    [set my-next-y my-y]
  ifElse my-next-heading-set
    [set my-heading my-next-heading
     set my-next-heading-set false]
    [set my-next-heading my-heading]
  report false
end

to initialise-patch-attributes
end

to initialise-globals [globals-not-to-be-initialised]
 set update-patch-attributes-needed false
end

to update-patch-attributes
end

to update-all-turtle-states
 if camera-tracks-centroid
  [let visible-objects all-individuals
   if any? visible-objects
     [set mean-x mean [ my-x ] of visible-objects
      set mean-y mean [ my-y ] of visible-objects]]
 ; used to only do the following with objects-with-something-to-do but 
 ; state may have been set by a different agent
 let ignore objects with [update-turtle-state]
end

to-report update-turtle-state
 update-turtle-position
 if-else ( heading = previous-heading )
    [set heading my-heading ]
    [set my-heading heading ]
 set previous-heading heading 
 ; e.g. 365 and 5
 if heading != my-heading [set my-next-heading heading set my-next-heading-set true]
 ; colour and pen could be added
 report false
end

to update-turtle-position
 if-else ( xcor = previous-xcor ) and ( ycor = previous-ycor )
 [set previous-xcor my-x 
  set previous-ycor my-y 
  if camera-tracks-centroid
     [set previous-xcor previous-xcor - mean-x
      set previous-ycor previous-ycor - mean-y]
  ; check if there is patch where I'm going (delta from where I am)
  if-else patch-at ( previous-xcor - xcor ) ( previous-ycor - ycor ) = nobody
    [set hidden? true]
    [setxy previous-xcor previous-ycor 
     ; reset previous-xcor since there may be a very tiny round-off error
     set previous-xcor xcor 
     set previous-ycor ycor ]]
 [set my-x xcor 
  set my-y ycor 
  set my-next-x xcor 
  set my-next-y ycor 
  set previous-xcor my-x 
  set previous-ycor my-y ]
end

to go-forward [steps]
 let angle 90 - my-next-heading 
 ; subtract from 90 since if heading is straight up that is "really" -90
 set my-next-x-set true
 set my-next-x my-next-x + cos angle * steps
 set my-next-y-set true
 set my-next-y my-next-y + sin angle * steps
end

to turn-right [angle]
 set my-next-heading-set true
 set my-next-heading canonical-heading ( my-next-heading + angle )
end

to initialise-previous-state
 set previous-xcor xcor 
 set previous-ycor ycor 
 set previous-heading heading 
end

to initialise-attributes
 set my-next-x-set false
 set my-next-y-set false
 set my-next-heading-set false
end

; The following are NetLogo library procedures and reporters used by the BehaviourComposer
; New BSD license
; See http://modelling4all.org
; Authored by Ken Kahn; Last updated 16 January 2017 to be compatible with NetLogo 6.0



to start [globals-not-to-be-initialised]
 initialise globals-not-to-be-initialised
 the-model globals-not-to-be-initialised
 finish-setup
 create-pens 1 ; for drawing lines
 ask pens [hide-turtle]
end

to setup
  setup-except []
end

to setup-except [globals-not-to-be-initialised]
 start globals-not-to-be-initialised
 set total-time 0
 if go-until (delta-t - .000001) []  ; ignore result
 ask objects [initialise-previous-state]
end

to initialise [globals-not-to-be-initialised]
 let saved-global-values map runresult globals-not-to-be-initialised
 if-else maximum-plot-generations > 0
    [if-else plot-generation <= maximum-plot-generations
        [let next-plot-generation plot-generation + 1
         ; clear all but plots and output
         clear-patches
         clear-drawing
         clear-turtles
         clear-globals
         set plot-generation next-plot-generation]
        [clear-all
         set plot-generation 0]]
    [clear-all]
 ;; restore the value of any variables in globals-not-to-be-initialised
 let i 0
 while [i < length globals-not-to-be-initialised]
       [let variable item i globals-not-to-be-initialised
        let value item i saved-global-values
        if (not is-number? value and not is-boolean? value and not is-list? value) [set value (word "\"" value "\"")]
        run (word "set " variable " " value)
        set i i + 1]
 reset-timer
 set time -1
 set times-scheduled []
 set behind-schedule 0
 set plotting-commands []
 set histogram-plotting-commands []
 set button-command ""
 set radian 57.29577951308232
 set need-to-clear-drawing false
 set observer-commands []
 set stop-running false
 if delta-t = 0 [set delta-t 1] ; give default value if none given
 if frame-duration = 0 [set frame-duration delta-t]
 if world-geometry = 0 [set world-geometry 1]
 ask-every-patch [ [] -> initialise-patch-attributes ]
 reset-ticks
end

to initialise-object
 set scheduled-behaviours []
 set current-behaviours []
 set behaviour-removals []
 set rules []
 set dead false
 initialise-attributes
end

to finish-setup
 ; faster than ask objects since doesn't shuffle
 set objects-with-something-to-do objects
 let ignore1 objects with [update-attributes]
 ask objects with [rules != []] [run-rules]
 update-all-turtle-states
 set time 0
end

to go
 reset-timer ; reset timer so pause and resume don't have leftover time
 if go-until -1
    [set stop-running false ; so it can be started up again
     stop]
    set total-time total-time + timer
end

to setup-only-if-needed
  if times-scheduled = 0 [setup]
end

to-report go-until [stop-time]
 ; this is run by the 'go' button and runs the scheduled events and updates the turtle states and plots
 setup-only-if-needed
 if observer-commands != []
    [run-observer-commands]
 if-else times-scheduled = []
   ; following uses a hack to avoid the overhead of ask shuffling the agent set
   [set objects-with-something-to-do objects with [rules != []]
    ask objects-with-something-to-do [run-rules] ; nothing scheduled but rules may be triggered by time
    ; rules may have added behaviours or set 'dead' so can't re-use objects-with-something-to-do
    ask objects [finish-tick]
    if observer-commands != []
       [run-observer-commands]
    set time time + frame-duration]
   [if-else time <= 0
      [set cycle-finish-time first times-scheduled]
      [set cycle-finish-time cycle-finish-time + frame-duration]
     if stop-time > 0 [set cycle-finish-time stop-time]
     while [times-scheduled != [] and first times-scheduled <= cycle-finish-time]
       [; nothing happening so skip ahead to next event
        set time first times-scheduled
        set times-scheduled but-first times-scheduled
        set objects-with-something-to-do objects with [scheduled-behaviours != [] or rules != []]
        ask objects-with-something-to-do [start-tick]
        ; above may have added behaviours or set 'dead' so can't re-use objects-with-something-to-do
        ask objects [finish-tick]
        if observer-commands != []
           [run-observer-commands]
        if need-to-clear-drawing
           [clear-drawing
            set need-to-clear-drawing false]]]
 if observer-commands != []
    [run-observer-commands]
 update-all-turtle-states
 if update-patch-attributes-needed [ask-every-patch [ [] -> update-patch-attributes ]]
 tick-advance time - ticks
 run-plotting-commands
 report not any? objects = 0 or stop-running or (stop-time > 0 and time >= stop-time)
end

to run-observer-commands
  let commands observer-commands
  set observer-commands []
  ; run each command without ANY commands pending
  forEach commands [ [?1] -> run ?1 ]
end

to run-plotting-commands
 forEach plotting-commands [ [?1] -> if is-agent? first ?1 [ask first ?1 [update-plot item 1 ?1 runresult item 2 ?1 runresult item 3 ?1]] ]
 forEach histogram-plotting-commands [ [?1] -> if is-agent? first ?1 [ask first ?1 [update-histogram item 1 ?1 item 2 ?1 item 3 ?1]] ]
end

to add-to-plot [x y]
  ; if using multiple plot generations need to get the pen back to the beginning without drawing a line
  ; assumes the plot starts at zero (or very close to it -- after setup)
  if-else x <= .000001
     [plot-pen-up plotXY x y plot-pen-down]
     [plotXY x y]
end

to update-plot [name-of-plot x y]
 if time >= 0
  [set-current-plot name-of-plot
   plotxy x y]
end

to update-histogram [name-of-plot population-reporter value-reporter]
 if time >= 0
  [set-current-plot name-of-plot
   histogram [runresult value-reporter] of runresult population-reporter]
end

;; behaviours are represented by a list:
;; scheduled-time behaviour-name
;; behaviours are kept in ascending order of the scheduled-time

to remove-behaviour-now [name]
 set scheduled-behaviours remove-behaviour-from-list name scheduled-behaviours
end

to do-every [interval actions]
 ; does it now and schedules the next occurrence interval ticks in the future
 ; schedules first in case action updates the current-behaviour variable
 if-else not is-number? interval or interval <= 0
   [user-message (word "Can only repeat something a positive number of times. Not " interval " " actions)]
   [if-else time < 0
      [insert-behaviour 0 (list (list actions interval))]
      [do-every-internal interval actions]]
end

to do-every-internal [interval actions]
 insert-behaviour time + interval (list (list actions interval))
 run-procedure actions
end

to do-every-dynamic [interval-reporter actions]
 insert-behaviour time + run-result interval-reporter (list (list actions interval-reporter))
 run-procedure actions
end

to add-copies [n behaviours]
 hatch n
       [set dead false
        let ignore update-attributes
        if-else (behaviours-at-tick-start = 0)
           ; this is called during initialisation so fall back on the old way of doing things
           [set scheduled-behaviours merge-behaviours scheduled-behaviours current-behaviours
            set scheduled-behaviours remove current-behaviour scheduled-behaviours]
           [set scheduled-behaviours behaviours-at-tick-start]
        forEach behaviours [ [?1] -> run ?1 ] ]
end

to start-tick
 set behaviours-at-tick-start scheduled-behaviours
 set current-behaviours scheduled-behaviours
 set scheduled-behaviours []
 while [current-behaviours != []]
       [let simulation-time first first current-behaviours
        if-else simulation-time > time
          [set scheduled-behaviours merge-behaviours scheduled-behaviours current-behaviours
           set current-behaviours []] ; stop this round
          [set current-behaviour first current-behaviours
           forEach but-first current-behaviour run-procedure
           set current-behaviour 0
           ; procedure may have reset current-behaviours to []
           if current-behaviours != []
              [set current-behaviours but-first current-behaviours]]]
 if rules != [] [run-rules]
 if behaviour-removals != []
    [forEach behaviour-removals
        [ [?1] -> ask first ?1 [remove-behaviour-now item 1 ?1] ]
     set behaviour-removals []]
end

to finish-tick
 ; this should happen after all objects have run start-tick
 let ignore update-attributes
 if dead [die]
end

to-report all-of-kind [kind-name]
 report objects with [kind = kind-name]
end

to whenever [condition action]
 set rules fput (list condition action true) rules
end

to run-rules
 let current-rules rules
 set rules []
 ; so can remove a rule below while still going down the list
 ;; could add error handling below
 forEach current-rules
    [ [?1] -> if-else runresult first ?1
       [run first but-first ?1
        if item 2 ?1
           ; is a 'whenever' rule so put it back on the list of rules
           [set rules fput ?1 rules]]
       [set rules fput ?1 rules] ]
end

to insert-behaviour [scheduled-time rest-of-behaviour]
 ; inserts in schedule keeping it sorted by scheduled time
 set times-scheduled insert-ordered scheduled-time times-scheduled
 set scheduled-behaviours insert-behaviour-in-list scheduled-time rest-of-behaviour scheduled-behaviours
end

to-report insert-ordered [new-time times]
  if-else member? new-time times
    [report times]
    [report sort fput new-time times]
end

to-report insert-behaviour-in-list [scheduled-time rest-of-behaviour behaviours]
 ; recursive version took 10% longer
 let earlier-behaviours []
 while [behaviours != []]
    [let current-time first first behaviours
      if current-time = scheduled-time
        [let new-behaviour lput first rest-of-behaviour first behaviours
          report sentence earlier-behaviours fput new-behaviour but-first behaviours]
      if current-time > scheduled-time
        [report sentence earlier-behaviours fput fput scheduled-time rest-of-behaviour behaviours]
     set earlier-behaviours lput first behaviours earlier-behaviours
     set behaviours but-first behaviours]
 report sentence earlier-behaviours (list fput scheduled-time rest-of-behaviour)
end

to-report remove-behaviour-from-list [procedure-name behaviours]
 report map [ [?1] -> remove-behaviour-from-behaviours-at-time-t procedure-name ?1 ] behaviours
end

to-report remove-behaviour-from-behaviours-at-time-t [procedure-name behaviours-at-time-t]
 forEach but-first behaviours-at-time-t ; first is the time -- skip that
   [ [?1] -> if equivalent-micro-behaviour? (ifelse-value is-list? ?1 [first ?1] [?1]) procedure-name
      [report remove ?1 behaviours-at-time-t] ]
 report behaviours-at-time-t
end

to-report equivalent-micro-behaviour? [name-1 name-2]
 if (not is-string? name-1)
    [set name-1 (anonymous-function-to-name name-1)]
 if (not is-string? name-2)
    [set name-2 (anonymous-function-to-name name-2)]
 if (name-1 = name-2) [report true]
 ; ignore serial number since can be multiple occurrences of the same micro-behaviour
 if (substring name-1 0 (length name-1 - 8) = substring name-2 0 (length name-2 - 8)) [report true]
 report false
end

to-report anonymous-function-to-name [f]
  ; extracts the name where the anonymous function was defined
  let s (word f)
  let start-index position " procedure " s
  if (start-index = false) [report s]
  set start-index start-index + length " procedure "
  set s substring s start-index (length s - 1)
  let stop-index position ": " s
  if (stop-index = false) [report s]
  report substring s 0 stop-index
end

to remove-behaviours [behaviours]
 forEach behaviours [ [?1] -> remove-behaviour ?1 ]
end

to remove-behaviour [name]
  set behaviour-removals fput (list self name) behaviour-removals
end

to-report merge-behaviours [behaviours1 behaviours2]
 ; both lists are already sorted
 if behaviours1 = [] [report behaviours2]
 if behaviours2 = [] [report behaviours1]
 if-else first first behaviours1 < first first behaviours2
   [report fput first behaviours1 merge-behaviours but-first behaviours1 behaviours2]
   [report fput first behaviours2 merge-behaviours behaviours1 but-first behaviours2]
end

to-report second [l]
 report first but-first l
end

to-report all-individuals
 report objects with [not hidden?]
end

to ask-every-patch [procedure-name]
 ; a hack but faster since doesn't randomise the patches as ask does
 let ignore patches with [run-false procedure-name]
end

to-report run-false [procedure-name]
 run procedure-name
 report false
end

to-report camera-tracks-centroid
 report world-geometry = 5
end

to-report list-to-agentset [agent-list]
 ; deprecated but kept for backwards compatibility
 report turtle-set agent-list
end

to run-procedure [name]
 if-else is-list? name
    [let target-or-frequency item 1 name
     if-else is-number? target-or-frequency
        [do-every-internal target-or-frequency first name]
        [if-else is-agent? target-or-frequency
            [ask target-or-frequency [run first name]]
            [do-every-dynamic target-or-frequency first name] ]]
    [run name]
end

to-report canonical-heading [h]
 if h > 180 [report h - 360]
 if h < -180 [report h + 360]
 report h
end

@#$#@#$#@
GRAPHICS-WINDOW
104
10
618
545
10
10
24.0
1
10
1
1
1
0
1
1
1
-10
10
-10
10
1
0
1
time
30.0

BUTTON
5
5
66
40
SETUP
setup
NIL
1
T
OBSERVER
NIL
S
NIL
NIL
1

BUTTON
5
45
66
80
GO
go
T
1
T
OBSERVER
NIL
G
NIL
NIL
1

BUTTON
5
85
68
118
PAUSE
set stop-running true
NIL
1
T
OBSERVER
NIL
.
NIL
NIL
1

PLOT
5
550
420
809
Wolves x Sheeps
time
population
0.0
1.0
0.0
1.0
true
true
"" ""
PENS

@#$#@#$#@
## WHAT IS IT?

(a general understanding of what the model is trying to show or explain)

## HOW IT WORKS

(what rules the agents use to create the overall behavior of the model)

## HOW TO USE IT

(how to use the model, including a description of each of the items in the Interface tab)

## THINGS TO NOTICE

(suggested things for the user to notice while running the model)

## THINGS TO TRY

(suggested things for the user to try to do (move sliders, switches, etc.) with the model)

## EXTENDING THE MODEL

(suggested things to add or change in the Code tab to make the model more complicated, detailed, accurate, etc.)

## NETLOGO FEATURES

(interesting or unusual features of NetLogo that the model uses, particularly in the Code tab; or where workarounds were needed for missing features)

## RELATED MODELS

(models in the NetLogo Models Library and elsewhere which are of related interest)

## CREDITS AND REFERENCES

(a reference to the model's URL on the web if it has one, as well as any other necessary credits, citations, and links)

@#$#@#$#@
default
true
0
Polygon -7500403 true true 150 5 40 250 150 205 260 250

sheep 2
false
0
Polygon -7500403 true true 209 183 194 198 179 198 164 183 164 174 149 183 89 183 74 168 59 198 44 198 29 185 43 151 28 121 44 91 59 80 89 80 164 95 194 80 254 65 269 80 284 125 269 140 239 125 224 153 209 168
Rectangle -7500403 true true 180 195 195 225
Rectangle -7500403 true true 45 195 60 225
Rectangle -16777216 true false 180 225 195 240
Rectangle -16777216 true false 45 225 60 240
Polygon -7500403 true true 245 60 250 72 240 78 225 63 230 51
Polygon -7500403 true true 25 72 40 80 42 98 22 91
Line -16777216 false 270 137 251 122
Line -16777216 false 266 90 254 90

wolf 2
false
0
Rectangle -7500403 true true 195 106 285 150
Rectangle -7500403 true true 195 90 255 105
Polygon -7500403 true true 240 90 217 44 196 90
Polygon -16777216 true false 234 89 218 59 203 89
Rectangle -1 true false 240 93 252 105
Rectangle -16777216 true false 242 96 249 104
Rectangle -16777216 true false 241 125 285 139
Polygon -1 true false 285 125 277 138 269 125
Polygon -1 true false 269 140 262 125 256 140
Rectangle -7500403 true true 45 120 195 195
Rectangle -7500403 true true 45 114 185 120
Rectangle -7500403 true true 165 195 180 270
Rectangle -7500403 true true 60 195 75 270
Polygon -7500403 true true 45 105 15 30 15 75 45 150 60 120

@#$#@#$#@
NetLogo 6.0.1
@#$#@#$#@
default
0.0
-0.2 0 0.0 1.0
0.0 1 1.0 0.0
0.2 0 0.0 1.0
link direction
true
0
Line -7500403 true 150 150 90 180
Line -7500403 true 150 150 210 180
@#$#@#$#@
@#$#@#$#@
@#$#@#$#@
@#$#@#$#@
default
0.0
-0.2 0 0.0 1.0
0.0 1 1.0 0.0
0.2 0 0.0 1.0
link direction
true
0
Line -7500403 true 150 150 90 180
Line -7500403 true 150 150 210 180

@#$#@#$#@
0
@#$#@#$#@
